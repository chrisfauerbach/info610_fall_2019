<!DOCTYPE html>
<html>
  <head>
    <title>INFO 610 - Week 5</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

/* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
/* Two-column layout */
      .left-column-half {
        color: #777;
        width: 50%;
        height: 92%;
        float: left;
      }
      .right-column-half {
        width: 50%;
        float: right;
        padding-top: 1em;
        line-height: .9em;
      }

    table, td, th {
        border: 1px solid black;
        font-size: .9em;
    }

     li {
       line-height:2.5em;
    }

    </style>
  </head>
  <body>
    <textarea id="source">

# 

<div style="text-align:center;font-size: 3em;line-height:3em;"> INFO 610 Fall 2019 </div>
<div style="text-align:center;font-size: 1.5em;line-height:1.8em;">Week 5</div>
<div style="text-align:center;font-size: 1em;line-height:1.8em;">More on the SQL</div>
<div style="text-align:center;font-size: 1.9em;line-height:3em;">chrisfauerbach.github.io/info610_fall_2019/</div>
---
# SQL Review

* Serial and Identity Columns
* Materialized Views
* Query / Distinct
* Join types
* Grouping

---
# Sequence

In PostgreSQL, a sequence is a special kind of database object that generates a sequence of integers. A sequence is often used as a primary key column. Similar to the AUTO_INCREMENT concept in MySQL.

When creating a new table, the sequence is created through the SERIAL pseudo-type as follows:

```sql 
CREATE TABLE table_name(
    id SERIAL
);
```
By assigning the SERIAL pseudo-type to the id column, PostgreSQL will perform the following:

* Creates a sequence object and set the next value generated by the sequence as the default value for the column.
* Adds the NOT NULL constraint to the column because a sequence always generates an integer, which is a non-null value.


---
# Serial Types

* smallserial / <strong>serial</strong> / bigserial
* 2 / 4/ 8 byte integers
* Auto-incrementing integer values

---

|Name|Storage Size|Description|Range|
|--|--|--|--|
|smallint|2 bytes|small-range integer|-32768 to +32767|
|integer|4 bytes|typical choice for integer|-2147483648 to +2147483647|
|bigint|8 bytes|large-range integer|-9223372036854775808 to +9223372036854775807|
|decimal|variable|user-specified precision, exact|up to 131072 digits before the decimal point; up to 16383 digits after the decimal point|
|numeric|variable|user-specified precision, exact|up to 131072 digits before the decimal point; up to 16383 digits after the decimal point|
|real|4 bytes|variable-precision, inexact|6 decimal digits precision|
|double precision|8 bytes|variable-precision, inexact|15 decimal digits precision|
|smallserial|2 bytes|small autoincrementing integer|1 to 32767|
|serial|4 bytes|autoincrementing integer|1 to 2147483647|
|bigserial|8 bytes|large autoincrementing integer|1 to 9223372036854775807|

---
# How to create and use a serial field

It is important to note that the SERIAL does not implicitly create an index on the column or make the column as the primary key column. However, this can be done easily by specifying the PRIMARY KEY constraint for the SERIAL column.


```sql
CREATE TABLE fruits( id SERIAL PRIMARY KEY, name VARCHAR NOT NULL );

INSERT INTO fruits (name) values ('apple'), ('pear'), ('pawpaw'),('orange');

SELECT * FROM fruits;

```
|ID|Name|
|--|--|
|1|apple|
|2|pear|
|3|pawpaw|
|4|orange|

---
# Identity Column


PostgreSQL version 10 introduced a new feature called GENERATED AS IDENTITY constraint that allows you to automatically assign a unique value to a column. The GENERATED AS IDENTITY constraint is the SQL standard-conforming variant of the PostgreSQLâ€™s SERIAL column.

```sql
CREATE TABLE color (
    color_id INT GENERATED ALWAYS AS IDENTITY,
    color_name VARCHAR NOT NULL
);

INSERT INTO color (color_name) VALUES ('Red');

SELECT * FROM colors;
```
|ID|color|
|--|--|
|1|Red|


---
# Materialized Views

Materialized views in PostgreSQL use the rule system like views do, but persist the results in a table-like form. The main differences between:

```sql 
CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab; ```
and:

```sql 
CREATE TABLE mymatview AS SELECT * FROM mytab; ```

are that the materialized view cannot subsequently be directly updated and that the query used to create the materialized view is stored in exactly the same way that a view's query is stored, so that fresh data can be generated for the materialized view with:

```sql 
REFRESH MATERIALIZED VIEW mymatview; ```


---
While access to the data stored in a materialized view is often much faster than accessing the underlying tables directly or through a view, the data is not always current; yet sometimes current data is not needed. Consider a table which records sales:

```sql 
CREATE TABLE invoice (
    invoice_no    integer        PRIMARY KEY,
    seller_no     integer,       -- ID of salesperson
    invoice_date  date,          -- date of sale
    invoice_amt   numeric(13,2)  -- amount of sale
);
```
If people want to be able to quickly graph historical sales data, they might want to summarize, and they may not care about the incomplete data for the current date:

```sql
CREATE MATERIALIZED VIEW sales_summary AS
  SELECT
      seller_no,
      invoice_date,
      sum(invoice_amt)::numeric(13,2) as sales_amt
    FROM invoice
    WHERE invoice_date < CURRENT_DATE
    GROUP BY
      seller_no,
      invoice_date
    ORDER BY
      seller_no,
      invoice_date;
```
---
# Update Materialized View

This materialized view might be useful for displaying a graph in the dashboard created for salespeople. 

A job could be scheduled to update the statistics each night using this SQL statement:

```sql
REFRESH MATERIALIZED VIEW sales_summary;
```


---
# Distinct

<b>SELECT DISTINCT</b> eliminates duplicate rows from the result.

If SELECT DISTINCT is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates)


---
# In practice

```sql
CREATE TABLE t1 (
   id serial NOT NULL PRIMARY KEY,
   bcolor VARCHAR,
   fcolor VARCHAR
);

INSERT INTO t1 (bcolor, fcolor)
VALUES
   ('red', 'red'),
   ('red', 'red'),
   ('red', NULL),
   (NULL, 'red'),
   ('red', 'green'),
   ('red', 'blue'),
   ('green', 'red'),
   ('green', 'blue'),
   ('green', 'green'),
   ('blue', 'red'),
   ('blue', 'green'),
   ('blue', 'blue');

```
---

```sql
SELECT * FROM t1;
```

|ID|bcolor|fcolor|
|--|--|--|
|1|red|red|
|2|red|red|
|3|red||
|4||red|
|5|red|green|
|6|red|blue|
|7|green|red|
|8|green|blue|
|9|green|green|
|10|blue|red|
|11|blue|green|
|12|blue|blue|

---

```sql
SELECT * FROM t1;
```

|ID|bcolor|fcolor|
|--|--|--|
|1|red|red|
|2|red|red|
|3|red||
|4||red|
|5|red|green|
|6|red|blue|
|7|green|red|
|8|green|blue|
|9|green|green|
|10|blue|red|
|11|blue|green|
|12|blue|blue|


---

```sql

select distinct bcolor from t1

```

|bcolor|
|--|
|(null)|
|green|
|blue|
|red|


---
# Joins

* Left Outer
* Inner
* Right Outer
* Full Outer

---

<img src="joins.png" width="95%"/>
---

# Aggregations next week


---
# Homework

We need a project to build on.   

What type of database should we design?

Employees?

Sales?

Inventory?

Social Network?


---

---

---

---

---

---

---

---

---











    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
